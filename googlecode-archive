#!/usr/bin/env bash

# Copyright (c) 2016, Cody Opel <codyopel@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Dependencies:
# bash >=4.2
# coreutils
# curl >=7.33.0
# grep
# jq
# tar
# unzip
# xz

# Notes:
# - Issue pages are only duplicate metadata that can be re-generated
#   from the issues themselves.
# - Issue API is incorrectly documented.

set -o pipefail

LIB_BASH="$(
  readlink -f "$(
    readlink -f "$(
      dirname "$(
        readlink -f "${0}"
      )"
    )"
  )/vendor/lib-bash/src/share/lib-bash/lib.bash"
)"

if [ -f "${LIB_BASH}" ] ; then
  source "${LIB_BASH}"
elif type 'git' > /dev/null ; then
  git submodule update --init --recursive
  source "${LIB_BASH}"
else
  echo 'ERROR: lib-bash is missing'
  exit 1
fi

# URL
declare -r GSAPI='https://storage.googleapis.com'
# Buckets
declare -r ABK='google-code-archive'
declare -r ASBK='google-code-archive-source'
declare -r ATBK='google-code-attachments'
declare -r DBK='google-code-archive-downloads'
# API
# 'v2/apache-extras.org'
# 'v2/eclipselabs.org'
declare -r CGC="${API:-v2/code.google.com}"

declare -r OUTDIRDEFAULT=`pwd`
declare -r OUTDIR="${OUTDIR:-${OUTDIRDEFAULT}}"

CONCURRENT_COMPACT='true'
CONCURRENT_LIMIT='50'
declare -r ENABLE_DEBUGGING='false'

CURL_ARGS=(
  '--continue-at -'
  '--http2'
  '--ssl-reqd'
  '--tlsv1.2'
  '--max-redirs 20'
  '--speed-limit 10240'
  '--speed-time 10'
  '--retry 32'
  '--retry-delay 5'
)

echo ${CURL_ARGS[@]}

GoogleCode::Downloads.file() {
  local -r DownloadFile="${2}"
  local -r Name="${1}"

  curl ${CURL_ARGS[@]} "${GSAPI}/${DBK}/${CGC}/${Name}/${DownloadFile}" \
    -o "${OUTDIR}/${Name}/downloads/${DownloadFile}"

  GoogleCode::InvalidKey.rm \
    "${OUTDIR}/${Name}/downloads/${DownloadFile}"
}

GoogleCode::Downloads.pages() {
  local -r DownloadPageNum="${2}"
  local -r Name="${1}"

  Directory::Create "${OUTDIR}/${Name}/downloads"

  curl ${CURL_ARGS[@]} \
    "${GSAPI}/${ABK}/${CGC}/${Name}/downloads-page-${DownloadPageNum}.json" \
    -o "${OUTDIR}/${Name}/downloads/downloads-page-${DownloadPageNum}.json"

  GoogleCode::InvalidKey.rm \
    "${OUTDIR}/${Name}/downloads/downloads-page-${DownloadPageNum}.json"
}

# TODO: vailidate download against provided sha1 hash
GoogleCode::Downloads() {
  local -a CCArgs1
  local -a CCArgs2
  local DownloadFile
  local -a DownloadFiles
  local DownloadPages
  local Name="${1}"
  local TestForInvalidKey
  local TMPDIR

  TMPDIR=`mktemp -d`

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/downloads-page-1.json" \
    -o "${TMPDIR}/downloads-page-1.json"

  GoogleCode::InvalidKey "${TMPDIR}/downloads-page-1.json" || return 0

  DownloadPages="$(jq -r -c -M '.totalPages' "${TMPDIR}/downloads-page-1.json")"

  for i in `seq 1 ${DownloadPages}` ; do
    CCArgs1+=(
      '-'
      "fetching: downloads-page-${i}.json"
      GoogleCode::Downloads.pages
        "${Name}"
        "${i}"
    )
  done

  GoogleCode::Step 'fetching download pages'

  concurrent "${CCArgs1[@]}"

  while read DownloadPageFile ; do
    while read DownloadFile ; do
      DownloadFiles+=("${DownloadFile}")
    done < <(jq -r -c -M '.downloads[].filename' "${DownloadPageFile}")
  done < <(find "${OUTDIR}"/"${Name}"/downloads -type f -name '*.json')

  for i in "${DownloadFiles[@]}" ; do
    CCArgs2+=(
      '-'
      "fetching download: ${i}"
      GoogleCode::Downloads.file
        "${Name}"
        "${i}"
    )
  done

  GoogleCode::Step 'fetching downloads'

  concurrent "${CCArgs2[@]}"
}

# Return 1 if key is invalid
GoogleCode::InvalidKey() {
  local -r File="${1}"
  local TestForInvalidKey

  TestForInvalidKey="$(
    cat "${File}" |
      grep -o 'The specified key does not exist.' || :
  )"

  if [ -n "${TestForInvalidKey}" ] ; then
    return 1
  fi
}

GoogleCode::InvalidKey.rm() {
  local -r File="${1}"

  GoogleCode::InvalidKey "${File}" || rm "${File}"
}

GoogleCode::Issues.attachment() {
  local -r File="${4}"
  local -r IssueCommentNum="${3}"
  local -r IssueNum="${2}"
  local -r Name="${1}"

  Directory::Create "${OUTDIR}/${Name}/issues/${IssueNum}/${IssueCommentNum}"

  curl ${CURL_ARGS[@]} "${GSAPI}/${ATBK}/${Name}/${File}" \
    -o "${OUTDIR}/${Name}/issues/${IssueNum}/${IssueCommentNum}/${File}"

  GoogleCode::InvalidKey.rm \
    "${OUTDIR}/${Name}/issues/${IssueNum}/${IssueCommentNum}/${File}"
}

GoogleCode::Issues.issue() {
  local IssueNum="${2}"
  local Name="${1}"

  Directory::Create "${OUTDIR}/${Name}/issues/${IssueNum}/"

  curl ${CURL_ARGS[@]} \
    "${GSAPI}/${ABK}/${CGC}/${Name}/issues/issue-${IssueNum}.json" \
    -o "${OUTDIR}/${Name}/issues/${IssueNum}/issue-${IssueNum}.json"

  GoogleCode::InvalidKey.rm \
    "${OUTDIR}/${Name}/issues/${IssueNum}/issue-${IssueNum}.json"
}

GoogleCode::Issues() {
  local Attachment
  local -a Attachments
  local -a CCArgs1
  local -a CCArgs2
  local IssueCommentNum
  local IssueNum
  local -a IssuePagesArray
  local Name="${1}"
  local NumIssues
  local TMPDIR

  TMPDIR=`mktemp -d`

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/issues-page-1.json" \
    -o "${TMPDIR}/issues.json"

  GoogleCode::InvalidKey "${TMPDIR}/issues.json" || return 0

  NumIssues="$(jq -r -c -M 'first(.issues[].id)' "${TMPDIR}/issues.json")"

  Var::Type.integer "${NumIssues}"

  for i in `seq 1 ${NumIssues}` ; do
    CCArgs1+=(
      '-' "fetching issue: ${i}" GoogleCode::Issues.issue "${Name}" "${i}"
    )
  done

  GoogleCode::Step 'fetching issues'

  concurrent "${CCArgs1[@]}"

  GoogleCode::Step 'compiling list of attachments'

  while read IssueFile ; do
    GoogleCode::InvalidKey "${IssueFile}" || {
      rm "${IssueFile}"
      continue
    }

    IssueNum="$(jq -r -c -M '.id' "${IssueFile}")"
    Var::Type.integer "${IssueNum}"

    jq -r -c -M '.comments' "${IssueFile}" > "${TMPDIR}/IssueCommentJson"

    while read IssueCommentNum ; do
      Var::Type.integer "${IssueCommentNum}"

      jq -r -c -M ".[]|select(.id | contains(${IssueCommentNum}))|.attachments" \
        "${TMPDIR}/IssueCommentJson" > \
        "${TMPDIR}/IssueAttachmentsJson"

      while read IssueAttachmentFile ; do
        Attachments+=("${IssueAttachmentFile}")
      done < <(jq -r -c -M '.[]|.fileName' "${TMPDIR}/IssueAttachmentsJson")

      for Attachment in "${Attachments[@]}" ; do
        CCArgs2+=(
          '-'
          "fetching issue: ${IssueNum}, comment: ${IssueCommentNum}, attachment: ${Attachment}"
          GoogleCode::Issues.attachment
            "${Name}"
            "${IssueNum}"
            "${IssueCommentNum}"
            "${Attachment}"
        )
      done
      unset Attachments
    done < <(jq -r -c -M '.[]|.id' "${TMPDIR}/IssueCommentJson")
  done < <(find "${OUTDIR}/${Name}/issues" -type f -name '*.json')

  GoogleCode::Step 'fetching issue attachements'

  [ ${#CCArgs2[@]} -ge 1 ] || return 0

  concurrent "${CCArgs2[@]}"
}

GoogleCode::Logo() {
  local Name="${1}"

  Directory::Create "${OUTDIR}/${Name}"

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/logo.png" \
    -o "${OUTDIR}/${Name}/logo.png"

  GoogleCode::InvalidKey.rm "${OUTDIR}/${Name}/logo.png"
}

# TODO: add support for sub repos, requires parsing project.json
# FIXME: check hasSource from project.json
GoogleCode::Repos() {
  local -r Name="${1}"
  local HasSource
  local TMPDIR

  TMPDIR=`mktemp -d`

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/project.json" \
    -o "${TMPDIR}/project.json"

  HasSource="$(jq -r -c -M '.hasSource' "${TMPDIR}/project.json")"

  [ "${HasSource}" == 'true' ] || return 0

  Directory::Create "${OUTDIR}/${Name}/repo/"

  GoogleCode::Step 'fetching source code archive'

  curl ${CURL_ARGS[@]} "${GSAPI}/${ASBK}/${CGC}/${Name}/source-archive.zip" \
    -o "${TMPDIR}/source-archive.zip"

  unzip -q "${TMPDIR}/source-archive.zip" -d "${OUTDIR}/${Name}/repo/"
}

GoogleCode::Step() {
  local -r Step="${1}"

  echo "########## ${Step} ##########">&1
}

GoogleCode::TarOutput() {
  local -r Name="${1}"

  File::Remove "${OUTDIR}/${Name}.tar.xz"

  # Don't tar an empty directory
  [ "$(du -b "${OUTDIR}/${Name}" | awk '{print $1;exit}')" != '0' ] || {
    Directory::Remove "${OUTDIR}/${Name}"
    return 0
  }

  # Prevent full directory heirarchy from being included, use
  # a relative path.
  pushd "${OUTDIR}" > /dev/null
    tar -cf - "${Name}" | xz -9 -c - > "${Name}.tar.xz"
  popd > /dev/null

  Directory::Remove "${OUTDIR}/${Name}"
}

GoogleCode::Wikis() {
  local -a CCArgs
  local -r Name="${1}"
  local TMPDIR
  local WikiFile
  local -a WikiFiles

  TMPDIR=`mktemp -d`

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/wikis.json" \
    -o "${TMPDIR}/wikis.json"

  GoogleCode::InvalidKey "${TMPDIR}/wikis.json" || return 0

  # Make sure not to interate over null
  [ -z "$(cat "${TMPDIR}/wikis.json" |
          grep -o '{"WikiFiles":null}' || :)" ] || return 0

  while read WikiFile ; do
    # Remove leading slash
    WikiFile="$(echo "${WikiFile}" | sed -e 's,^/,,')"
    WikiFiles+=("${WikiFile}")
  done < <(jq -r '.WikiFiles[]' "${TMPDIR}/wikis.json")

  for i in "${WikiFiles[@]}" ; do
    if [ -n "${i}" ] ; then
      CCArgs+=(
        '-'
        "fetching wiki page: ${i}"
        GoogleCode::Wikis.page
          "${Name}"
          "${i}"
      )
    fi
  done

  echo "${CCArgs[@]}"
  [ ${#CCArgs[@]} -ge 1 ] || return 0

  GoogleCode::Step 'fetching wiki pages'

  concurrent "${CCArgs[@]}"
}

GoogleCode::Wikis.page() {
  local -r Name="${1}"
  local -r File="${2}"

  Directory::Create "${OUTDIR}/${Name}/wikis/$(dirname "${File}" | sed -e 's/^.//')"

  curl ${CURL_ARGS[@]} "${GSAPI}/${ABK}/${CGC}/${Name}/wiki/${File}" \
    -o "${OUTDIR}/${Name}/wikis/${File}"

  GoogleCode::InvalidKey.rm "${OUTDIR}/wikis/${File}"
}

GoogleCode::Project() {
  local -r Name="${1}"

  Directory::Remove "${OUTDIR}/${Name}"

  GoogleCode::Step "checking for downloads"
  GoogleCode::Downloads "${Name}"

  GoogleCode::Step "checking for issues"
  GoogleCode::Issues "${Name}"

  GoogleCode::Step 'fetching logo'
  GoogleCode::Logo "${Name}"

  GoogleCode::Repos "${Name}"

  GoogleCode::Step 'checking for wikis'
  GoogleCode::Wikis "${Name}"

  GoogleCode::Step 'tarring output'
  GoogleCode::TarOutput "${Name}"
}

GoogleCode::Main() {
  local -r Name="${1}"

  # TCP connections could be dropped and it isn't worth implementing
  # detection for this, so loop until the program succeeds.
  while [ true ] ; do
    GoogleCode::Project "${Name}" && {
      false
    }
  done

  return 0
}

if [ -f "${1}" ] ; then
  # TODO: support reading in file
  :
else
  [ -n "${1}" ] || {
    Debug::Message 'error' "no input"
    exit 1
  }
  GoogleCode::Main "${1}"
fi

exit 0
